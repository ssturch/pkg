package main

import (
	"strings"

	"google.golang.org/genproto/googleapis/api/annotations"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
)

func main() {
	protogen.Options{}.Run(func(plugin *protogen.Plugin) error {
		for _, f := range plugin.Files {
			if !f.Generate || len(f.Services) == 0 {
				continue
			}

			filename := f.GeneratedFilenamePrefix + "_client.ts"
			g := plugin.NewGeneratedFile(filename, "")

			g.P("// Code generated by protoc-gen-ts-axios. DO NOT EDIT.")
			// g.P("import axios from 'axios';")
			g.P("import { AxiosInstance } from 'axios';")

			importMap := make(map[string]map[string]int)

			for _, service := range f.Services {
				for _, method := range service.Methods {
					parseImport(importMap, method.Input.Desc)
					parseImport(importMap, method.Output.Desc)
				}
			}

			for importPath, importTypes := range importMap {
				keys := MapKeys(importTypes)
				g.P("import { ", strings.Join(keys, ", "), " } from '", importPath, "';")
			}

			g.P()

			for _, service := range f.Services {
				clientName := service.GoName + "Client"
				g.P("export const New", clientName, " = (client: AxiosInstance) => ({")

				// g.P("export class ", clientName, " {")
				// g.P("  constructor(private readonly client: AxiosInstance) {}")
				// g.P()

				for _, method := range service.Methods {
					opts := method.Desc.Options().(*descriptorpb.MethodOptions)
					rule, ok := proto.GetExtension(opts, annotations.E_Http).(*annotations.HttpRule)
					if !ok {
						continue
					}

					methodVerb, methodPath := ExtractVerbAndPath(rule)

					inputType := method.Input.Desc.Name()
					outputType := method.Output.Desc.Name()
					methodName := method.GoName

					g.P("\t", methodName, ": async (request: ", inputType, "): Promise<", outputType, "> =>")
					g.P("\t\t", outputType, ".fromJSON(await client.", methodVerb, "('", methodPath, "', ", inputType, ".toJSON(request))),")
				}
				g.P("})")
			}
		}

		return nil
	})
}

const apiPathPrefix = "@api/"
const protoSuffix = ".proto"

// Parse the import path and type name from the message descriptor and add it to the import map.
func parseImport(importMap map[string]map[string]int, messageDesc protoreflect.MessageDescriptor) {
	messageType := string(messageDesc.Name())
	inputPath := apiPathPrefix + strings.TrimSuffix(messageDesc.ParentFile().Path(), protoSuffix)
	importTypes := importMap[inputPath]
	if importTypes == nil {
		importTypes = make(map[string]int)
		importMap[inputPath] = importTypes
	}
	importTypes[messageType]++
}

func MapKeys[T any, K comparable](m map[K]T) []K {
	keys := make([]K, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	return keys
}
func ExtractVerbAndPath(rule *annotations.HttpRule) (verb, path string) {
	switch pattern := rule.Pattern.(type) {
	case *annotations.HttpRule_Get:
		return "get", pattern.Get
	case *annotations.HttpRule_Post:
		return "post", pattern.Post
	case *annotations.HttpRule_Put:
		return "put", pattern.Put
	case *annotations.HttpRule_Patch:
		return "patch", pattern.Patch
	case *annotations.HttpRule_Delete:
		return "delete", pattern.Delete
	default:
		return "", ""
	}
}
